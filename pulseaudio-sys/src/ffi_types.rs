// Copyright Â© 2017-2018 The Cubeb Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![allow(non_camel_case_types)]

use std::os::raw::{c_char, c_int, c_long, c_uint, c_ulong, c_void};

/* automatically generated by rust-bindgen */
pub const PA_RATE_MAX: c_uint = 48000 * 8;

pulse_enum! {
    pub enum pa_sample_format_t: c_int {
        PA_SAMPLE_INVALID = -1,
        PA_SAMPLE_U8 = 0,
        PA_SAMPLE_ALAW = 1,
        PA_SAMPLE_ULAW = 2,
        PA_SAMPLE_S16LE = 3,
        PA_SAMPLE_S16BE = 4,
        PA_SAMPLE_FLOAT32LE = 5,
        PA_SAMPLE_FLOAT32BE = 6,
        PA_SAMPLE_S32LE = 7,
        PA_SAMPLE_S32BE = 8,
        PA_SAMPLE_S24LE = 9,
        PA_SAMPLE_S24BE = 10,
        PA_SAMPLE_S24_32LE = 11,
        PA_SAMPLE_S24_32BE = 12,
        PA_SAMPLE_MAX = 13,
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct pa_sample_spec {
    pub format: pa_sample_format_t,
    pub rate: c_uint,
    pub channels: u8,
}

impl ::std::default::Default for pa_sample_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_usec_t = u64;

// From pulse/timeval.h
pub const PA_USEC_PER_MSEC: pa_usec_t = 1_000;
pub const PA_USEC_PER_SEC: pa_usec_t = 1_000_000;

pulse_enum! {
    pub enum pa_context_state_t {
        PA_CONTEXT_UNCONNECTED = 0,
        PA_CONTEXT_CONNECTING = 1,
        PA_CONTEXT_AUTHORIZING = 2,
        PA_CONTEXT_SETTING_NAME = 3,
        PA_CONTEXT_READY = 4,
        PA_CONTEXT_FAILED = 5,
        PA_CONTEXT_TERMINATED = 6,
    }
}

pub fn pa_context_is_good(x: pa_context_state_t) -> bool {
    x == PA_CONTEXT_CONNECTING || x == PA_CONTEXT_AUTHORIZING || x == PA_CONTEXT_SETTING_NAME
        || x == PA_CONTEXT_READY
}

pulse_enum! {
    pub enum pa_stream_state_t {
        PA_STREAM_UNCONNECTED = 0,
        PA_STREAM_CREATING = 1,
        PA_STREAM_READY = 2,
        PA_STREAM_FAILED = 3,
        PA_STREAM_TERMINATED = 4,
    }
}

pub fn pa_stream_is_good(x: pa_stream_state_t) -> bool {
    x == PA_STREAM_CREATING || x == PA_STREAM_READY
}

pulse_enum! {
    pub enum pa_operation_state_t {
        PA_OPERATION_RUNNING,
        PA_OPERATION_DONE,
        PA_OPERATION_CANCELLED,
    }
}

pulse_enum! {
    pub enum pa_context_flags_t {
        PA_CONTEXT_NOFLAGS = 0,
        PA_CONTEXT_NOAUTOSPAWN,
        PA_CONTEXT_NOFAIL,
    }
}

// TODO: This might be flags
pulse_enum! {
    pub enum pa_direction_t {
        PA_DIRECTION_OUTPUT = 1,
        PA_DIRECTION_INPUT = 2,
    }
}

pulse_enum! {
    pub enum pa_device_type_t {
        PA_DEVICE_TYPE_SINK,
        PA_DEVICE_TYPE_SOURCE,
    }
}

pulse_enum! {
    pub enum pa_stream_direction_t {
        PA_STREAM_NODIRECTION,
        PA_STREAM_PLAYBACK,
        PA_STREAM_RECORD,
        PA_STREAM_UPLOAD,
    }
}

pulse_flags! {
    pub flags pa_stream_flags_t {
        PA_STREAM_NOFLAGS = 0,
        PA_STREAM_START_CORKED,
        PA_STREAM_INTERPOLATE_TIMING,
        PA_STREAM_NOT_MONOTONIC,
        PA_STREAM_AUTO_TIMING_UPDATE,
        PA_STREAM_NO_REMAP_CHANNELS,
        PA_STREAM_NO_REMIX_CHANNELS,
        PA_STREAM_FIX_FORMAT,
        PA_STREAM_FIX_RATE,
        PA_STREAM_FIX_CHANNELS,
        PA_STREAM_DONT_MOVE,
        PA_STREAM_VARIABLE_RATE,
        PA_STREAM_PEAK_DETECT,
        PA_STREAM_START_MUTED,
        PA_STREAM_ADJUST_LATENCY,
        PA_STREAM_EARLY_REQUESTS,
        PA_STREAM_DONT_INHIBIT_AUTO_SUSPEND,
        PA_STREAM_START_UNMUTED,
        PA_STREAM_FAIL_ON_SUSPEND,
        PA_STREAM_RELATIVE_VOLUME,
        PA_STREAM_PASSTHROUGH,
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_buffer_attr {
    pub maxlength: c_uint,
    pub tlength: c_uint,
    pub prebuf: c_uint,
    pub minreq: c_uint,
    pub fragsize: c_uint,
}

impl ::std::default::Default for pa_buffer_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pulse_enum! {
    pub enum pa_error_code_t {
        PA_OK,
        PA_ERR_ACCESS,
        PA_ERR_COMMAND,
        PA_ERR_INVALID,
        PA_ERR_EXIST,
        PA_ERR_NOENTITY,
        PA_ERR_CONNECTIONREFUSED,
        PA_ERR_PROTOCOL,
        PA_ERR_TIMEOUT,
        PA_ERR_AUTHKEY,
        PA_ERR_INTERNAL,
        PA_ERR_CONNECTIONTERMINATED,
        PA_ERR_KILLED,
        PA_ERR_INVALIDSERVER,
        PA_ERR_MODINITFAILED,
        PA_ERR_BADSTATE,
        PA_ERR_NODATA,
        PA_ERR_VERSION,
        PA_ERR_TOOLARGE,
        PA_ERR_NOTSUPPORTED,
        PA_ERR_UNKNOWN,
        PA_ERR_NOEXTENSION,
        PA_ERR_OBSOLETE,
        PA_ERR_NOTIMPLEMENTED,
        PA_ERR_FORKED,
        PA_ERR_IO,
        PA_ERR_BUSY,
        PA_ERR_MAX,
    }
}

pulse_flags! {
    pub flags pa_subscription_mask_t {
        PA_SUBSCRIPTION_MASK_NULL = 0,
        PA_SUBSCRIPTION_MASK_SINK,
        PA_SUBSCRIPTION_MASK_SOURCE,
        PA_SUBSCRIPTION_MASK_SINK_INPUT,
        PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT,
        PA_SUBSCRIPTION_MASK_MODULE,
        PA_SUBSCRIPTION_MASK_CLIENT,
        PA_SUBSCRIPTION_MASK_SAMPLE_CACHE,
        PA_SUBSCRIPTION_MASK_SERVER,
        PA_SUBSCRIPTION_MASK_AUTOLOAD,
        PA_SUBSCRIPTION_MASK_CARD,
        PA_SUBSCRIPTION_MASK_ALL = 0x2FF,
    }
}

pulse_enum! {
    pub enum pa_subscription_event_type_t {
        PA_SUBSCRIPTION_EVENT_SINK,
        PA_SUBSCRIPTION_EVENT_SOURCE,
        PA_SUBSCRIPTION_EVENT_SINK_INPUT,
        PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT,
        PA_SUBSCRIPTION_EVENT_MODULE,
        PA_SUBSCRIPTION_EVENT_CLIENT,
        PA_SUBSCRIPTION_EVENT_SAMPLE_CACHE,
        PA_SUBSCRIPTION_EVENT_SERVER,
        PA_SUBSCRIPTION_EVENT_AUTOLOAD,
        PA_SUBSCRIPTION_EVENT_CARD,
        PA_SUBSCRIPTION_EVENT_FACILITY_MASK = 15,
        PA_SUBSCRIPTION_EVENT_NEW = 0,
        PA_SUBSCRIPTION_EVENT_CHANGE = 16,
        PA_SUBSCRIPTION_EVENT_REMOVE = 32,
        PA_SUBSCRIPTION_EVENT_TYPE_MASK = 48,
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct timeval {
    pub tv_sec: c_long,
    pub tv_usec: c_long,
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_timing_info {
    pub timestamp: timeval,
    pub synchronized_clocks: c_int,
    pub sink_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub transport_usec: pa_usec_t,
    pub playing: c_int,
    pub write_index_corrupt: c_int,
    pub write_index: i64,
    pub read_index_corrupt: c_int,
    pub read_index: i64,
    pub configured_sink_usec: pa_usec_t,
    pub configured_source_usec: pa_usec_t,
    pub since_underrun: i64,
}

impl ::std::default::Default for pa_timing_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_spawn_api {
    pub prefork: Option<extern "C" fn() -> ()>,
    pub postfork: Option<extern "C" fn() -> ()>,
    pub atfork: Option<extern "C" fn() -> ()>,
}

impl ::std::default::Default for pa_spawn_api {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pulse_enum! {
    pub enum pa_seek_mode_t {
        PA_SEEK_RELATIVE,
        PA_SEEK_ABSOLUTE,
        PA_SEEK_RELATIVE_ON_READ,
        PA_SEEK_RELATIVE_END,
    }
}

pulse_flags! {
    pub flags pa_sink_flags_t {
        PA_SINK_NOFLAGS = 0,
        PA_SINK_HW_VOLUME_CTRL,
        PA_SINK_LATENCY,
        PA_SINK_HARDWARE,
        PA_SINK_NETWORK,
        PA_SINK_HW_MUTE_CTRL,
        PA_SINK_DECIBEL_VOLUME,
        PA_SINK_FLAT_VOLUME,
        PA_SINK_DYNAMIC_LATENCY,
        PA_SINK_SET_FORMATS,
    }
}

pulse_enum! {
    pub enum pa_sink_state_t: c_int  {
        PA_SINK_UNLINKED = -3,
        PA_SINK_INIT = -2,
        PA_SINK_INVALID_STATE = -1,
        PA_SINK_RUNNING = 0,
        PA_SINK_IDLE = 1,
        PA_SINK_SUSPENDED = 2,
    }
}

pulse_flags! {
    pub flags pa_source_flags_t {
        PA_SOURCE_NOFLAGS = 0,
        PA_SOURCE_HW_VOLUME_CTRL,
        PA_SOURCE_LATENCY,
        PA_SOURCE_HARDWARE,
        PA_SOURCE_NETWORK,
        PA_SOURCE_HW_MUTE_CTRL,
        PA_SOURCE_DECIBEL_VOLUME,
        PA_SOURCE_DYNAMIC_LATENCY,
        PA_SOURCE_FLAT_VOLUME,
    }
}

pulse_enum! {
    pub enum pa_source_state_t: c_int {
        PA_SOURCE_UNLINKED = -3,
        PA_SOURCE_INIT = -2,
        PA_SOURCE_INVALID_STATE = -1,
        PA_SOURCE_RUNNING = 0,
        PA_SOURCE_IDLE = 1,
        PA_SOURCE_SUSPENDED = 2,
    }
}

pub type pa_free_cb_t = Option<unsafe extern "C" fn(p: *mut c_void) -> ()>;

pulse_enum! {
    pub enum pa_port_available_t {
        PA_PORT_AVAILABLE_UNKNOWN = 0,
        PA_PORT_AVAILABLE_NO = 1,
        PA_PORT_AVAILABLE_YES = 2,
    }
}

pulse_flags! {
    pub flags pa_io_event_flags_t {
        PA_IO_EVENT_NULL = 0,
        PA_IO_EVENT_INPUT,
        PA_IO_EVENT_OUTPUT,
        PA_IO_EVENT_HANGUP,
        PA_IO_EVENT_ERROR,
    }
}

pub enum pa_io_event {}
pub type pa_io_event_cb_t = Option<
    unsafe extern "C" fn(
        ea: *mut pa_mainloop_api,
        e: *mut pa_io_event,
        fd: c_int,
        events: pa_io_event_flags_t,
        userdata: *mut c_void,
    ),
>;
pub type pa_io_event_destroy_cb_t = Option<
    unsafe extern "C" fn(a: *mut pa_mainloop_api, e: *mut pa_io_event, userdata: *mut c_void),
>;
pub enum pa_time_event {}
pub type pa_time_event_cb_t = Option<
    unsafe extern "C" fn(
        a: *mut pa_mainloop_api,
        e: *mut pa_time_event,
        tv: *const timeval,
        userdata: *mut c_void,
    ),
>;
pub type pa_time_event_destroy_cb_t = Option<
    unsafe extern "C" fn(a: *mut pa_mainloop_api, e: *mut pa_time_event, userdata: *mut c_void),
>;

pub enum pa_defer_event {}
pub type pa_defer_event_cb_t = Option<
    unsafe extern "C" fn(a: *mut pa_mainloop_api, e: *mut pa_defer_event, userdata: *mut c_void),
>;
pub type pa_defer_event_destroy_cb_t = Option<
    unsafe extern "C" fn(a: *mut pa_mainloop_api, e: *mut pa_defer_event, userdata: *mut c_void),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_mainloop_api {
    pub userdata: *mut c_void,
    pub io_new: Option<
        unsafe extern "C" fn(
            a: *mut pa_mainloop_api,
            fd: c_int,
            events: pa_io_event_flags_t,
            cb: pa_io_event_cb_t,
            userdata: *mut c_void,
        ) -> *mut pa_io_event,
    >,
    pub io_enable: Option<unsafe extern "C" fn(e: *mut pa_io_event, events: pa_io_event_flags_t)>,
    pub io_free: Option<unsafe extern "C" fn(e: *mut pa_io_event)>,
    pub io_set_destroy:
        Option<unsafe extern "C" fn(e: *mut pa_io_event, cb: pa_io_event_destroy_cb_t)>,
    pub time_new: Option<
        unsafe extern "C" fn(
            a: *mut pa_mainloop_api,
            tv: *const timeval,
            cb: pa_time_event_cb_t,
            userdata: *mut c_void,
        ) -> *mut pa_time_event,
    >,
    pub time_restart: Option<unsafe extern "C" fn(e: *mut pa_time_event, tv: *const timeval)>,
    pub time_free: Option<unsafe extern "C" fn(e: *mut pa_time_event)>,
    pub time_set_destroy:
        Option<unsafe extern "C" fn(e: *mut pa_time_event, cb: pa_time_event_destroy_cb_t)>,
    pub defer_new: Option<
        unsafe extern "C" fn(
            a: *mut pa_mainloop_api,
            cb: pa_defer_event_cb_t,
            userdata: *mut c_void,
        ) -> *mut pa_defer_event,
    >,
    pub defer_enable: Option<unsafe extern "C" fn(e: *mut pa_defer_event, b: c_int)>,
    pub defer_free: Option<unsafe extern "C" fn(e: *mut pa_defer_event)>,
    pub defer_set_destroy:
        Option<unsafe extern "C" fn(e: *mut pa_defer_event, cb: pa_defer_event_destroy_cb_t)>,
    pub quit: Option<unsafe extern "C" fn(a: *mut pa_mainloop_api, retval: c_int)>,
}

impl ::std::default::Default for pa_mainloop_api {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub enum pa_proplist {}

pulse_enum! {
    pub enum pa_update_mode_t {
        PA_UPDATE_SET = 0,
        PA_UPDATE_MERGE = 1,
        PA_UPDATE_REPLACE = 2,
    }
}

pulse_enum! {
    pub enum pa_channel_position_t: c_int {
        PA_CHANNEL_POSITION_INVALID = -1,
        PA_CHANNEL_POSITION_MONO,
        PA_CHANNEL_POSITION_FRONT_LEFT,
        PA_CHANNEL_POSITION_FRONT_RIGHT,
        PA_CHANNEL_POSITION_FRONT_CENTER,
        PA_CHANNEL_POSITION_LEFT = 1,
        PA_CHANNEL_POSITION_RIGHT = 2,
        PA_CHANNEL_POSITION_CENTER = 3,
        PA_CHANNEL_POSITION_REAR_CENTER,
        PA_CHANNEL_POSITION_REAR_LEFT,
        PA_CHANNEL_POSITION_REAR_RIGHT,
        PA_CHANNEL_POSITION_LFE,
        PA_CHANNEL_POSITION_SUBWOOFER = 7,
        PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
        PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
        PA_CHANNEL_POSITION_SIDE_LEFT,
        PA_CHANNEL_POSITION_SIDE_RIGHT,
        PA_CHANNEL_POSITION_AUX0,
        PA_CHANNEL_POSITION_AUX1,
        PA_CHANNEL_POSITION_AUX2,
        PA_CHANNEL_POSITION_AUX3,
        PA_CHANNEL_POSITION_AUX4,
        PA_CHANNEL_POSITION_AUX5,
        PA_CHANNEL_POSITION_AUX6,
        PA_CHANNEL_POSITION_AUX7,
        PA_CHANNEL_POSITION_AUX8,
        PA_CHANNEL_POSITION_AUX9,
        PA_CHANNEL_POSITION_AUX10,
        PA_CHANNEL_POSITION_AUX11,
        PA_CHANNEL_POSITION_AUX12,
        PA_CHANNEL_POSITION_AUX13,
        PA_CHANNEL_POSITION_AUX14,
        PA_CHANNEL_POSITION_AUX15,
        PA_CHANNEL_POSITION_AUX16,
        PA_CHANNEL_POSITION_AUX17,
        PA_CHANNEL_POSITION_AUX18,
        PA_CHANNEL_POSITION_AUX19,
        PA_CHANNEL_POSITION_AUX20,
        PA_CHANNEL_POSITION_AUX21,
        PA_CHANNEL_POSITION_AUX22,
        PA_CHANNEL_POSITION_AUX23,
        PA_CHANNEL_POSITION_AUX24,
        PA_CHANNEL_POSITION_AUX25,
        PA_CHANNEL_POSITION_AUX26,
        PA_CHANNEL_POSITION_AUX27,
        PA_CHANNEL_POSITION_AUX28,
        PA_CHANNEL_POSITION_AUX29,
        PA_CHANNEL_POSITION_AUX30,
        PA_CHANNEL_POSITION_AUX31,
        PA_CHANNEL_POSITION_TOP_CENTER,
        PA_CHANNEL_POSITION_TOP_FRONT_LEFT,
        PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
        PA_CHANNEL_POSITION_TOP_FRONT_CENTER,
        PA_CHANNEL_POSITION_TOP_REAR_LEFT,
        PA_CHANNEL_POSITION_TOP_REAR_RIGHT,
        PA_CHANNEL_POSITION_TOP_REAR_CENTER,
        PA_CHANNEL_POSITION_MAX,
    }
}
pub type pa_channel_position_mask_t = u64;

pulse_enum! {
    pub enum pa_channel_map_def_t {
        PA_CHANNEL_MAP_AIFF,
        PA_CHANNEL_MAP_ALSA,
        PA_CHANNEL_MAP_AUX,
        PA_CHANNEL_MAP_WAVEEX,
        PA_CHANNEL_MAP_OSS,
        PA_CHANNEL_MAP_DEF_MAX,
        PA_CHANNEL_MAP_DEFAULT = 0,
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_channel_map {
    pub channels: u8,
    pub map: [pa_channel_position_t; 32usize],
}

impl ::std::default::Default for pa_channel_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pulse_enum! {
    pub enum pa_encoding_t: c_int {
        PA_ENCODING_INVALID = -1,
        PA_ENCODING_ANY,
        PA_ENCODING_PCM,
        PA_ENCODING_AC3_IEC61937,
        PA_ENCODING_EAC3_IEC61937,
        PA_ENCODING_MPEG_IEC61937,
        PA_ENCODING_DTS_IEC61937,
        PA_ENCODING_MPEG2_AAC_IEC61937,
        PA_ENCODING_MAX,
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_format_info {
    pub encoding: pa_encoding_t,
    pub plist: *mut pa_proplist,
}

impl ::std::default::Default for pa_format_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pulse_enum! {
    pub enum pa_prop_type_t: c_int {
        PA_PROP_TYPE_INVALID = -1,
        PA_PROP_TYPE_INT,
        PA_PROP_TYPE_INT_RANGE,
        PA_PROP_TYPE_INT_ARRAY,
        PA_PROP_TYPE_STRING,
        PA_PROP_TYPE_STRING_ARRAY,
    }
}

pub enum pa_operation {}
pub type pa_operation_notify_cb_t = Option<
    unsafe extern "C" fn(o: *mut pa_operation, userdata: *mut c_void),
>;

pub enum pa_context {}
pub type pa_context_notify_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, userdata: *mut c_void),
>;
pub type pa_context_success_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, success: c_int, userdata: *mut c_void),
>;
pub type pa_context_event_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        name: *const c_char,
        p: *mut pa_proplist,
        userdata: *mut c_void,
    ),
>;

pub type pa_volume_t = c_uint;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_cvolume {
    pub channels: u8,
    pub values: [pa_volume_t; 32usize],
}

impl ::std::default::Default for pa_cvolume {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub enum pa_stream {}
pub type pa_stream_success_cb_t = Option<
    unsafe extern "C" fn(s: *mut pa_stream, success: c_int, userdata: *mut c_void),
>;
pub type pa_stream_request_cb_t = Option<
    unsafe extern "C" fn(p: *mut pa_stream, nbytes: usize, userdata: *mut c_void),
>;
pub type pa_stream_notify_cb_t = Option<
    unsafe extern "C" fn(p: *mut pa_stream, userdata: *mut c_void),
>;
pub type pa_stream_event_cb_t = Option<
    unsafe extern "C" fn(
        p: *mut pa_stream,
        name: *const c_char,
        pl: *mut pa_proplist,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_sink_port_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub priority: u32,
    pub available: c_int,
}

impl ::std::default::Default for pa_sink_port_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_sink_info {
    pub name: *const c_char,
    pub index: u32,
    pub description: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: u32,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub monitor_source: u32,
    pub monitor_source_name: *const c_char,
    pub latency: pa_usec_t,
    pub driver: *const c_char,
    pub flags: pa_sink_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_sink_state_t,
    pub n_volume_steps: u32,
    pub card: u32,
    pub n_ports: u32,
    pub ports: *mut *mut pa_sink_port_info,
    pub active_port: *mut pa_sink_port_info,
    pub n_formats: u8,
    pub formats: *mut *mut pa_format_info,
}

impl ::std::default::Default for pa_sink_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_sink_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_sink_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_source_port_info {
    pub name: *const c_char,
    pub description: *const c_char,
    priority: u32,
    available: c_int,
}

impl ::std::default::Default for pa_source_port_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_source_info {
    pub name: *const c_char,
    pub index: u32,
    pub description: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub owner_module: c_uint,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub monitor_of_sink: u32,
    pub monitor_of_sink_name: *const c_char,
    pub latency: pa_usec_t,
    pub driver: *const c_char,
    pub flags: pa_source_flags_t,
    pub proplist: *mut pa_proplist,
    pub configured_latency: pa_usec_t,
    pub base_volume: pa_volume_t,
    pub state: pa_source_state_t,
    pub n_volume_steps: u32,
    pub card: u32,
    pub n_ports: u32,
    pub ports: *mut *mut pa_source_port_info,
    pub active_port: *mut pa_source_port_info,
    pub n_formats: u8,
    pub formats: *mut *mut pa_format_info,
}

impl ::std::default::Default for pa_source_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_source_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_source_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_server_info {
    pub user_name: *const c_char,
    pub host_name: *const c_char,
    pub server_version: *const c_char,
    pub server_name: *const c_char,
    pub sample_spec: pa_sample_spec,
    pub default_sink_name: *const c_char,
    pub default_source_name: *const c_char,
    pub cookie: c_uint,
    pub channel_map: pa_channel_map,
}

impl ::std::default::Default for pa_server_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_server_info_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, i: *mut pa_server_info, userdata: *mut c_void),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_module_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub argument: *const c_char,
    pub n_used: c_uint,
    pub auto_unload: c_int,
    pub proplist: *mut pa_proplist,
}

impl ::std::default::Default for pa_module_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_module_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_module_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;
pub type pa_context_index_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, idx: c_uint, userdata: *mut c_void),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_client_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub owner_module: c_uint,
    pub driver: *const c_char,
    pub proplist: *mut pa_proplist,
}

impl ::std::default::Default for pa_client_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_client_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_client_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_card_profile_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub n_sinks: c_uint,
    pub n_sources: c_uint,
    pub priority: c_uint,
}

impl ::std::default::Default for pa_card_profile_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_card_profile_info2 {
    pub name: *const c_char,
    pub description: *const c_char,
    pub n_sinks: c_uint,
    pub n_sources: c_uint,
    pub priority: c_uint,
    pub available: c_int,
}

impl ::std::default::Default for pa_card_profile_info2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_card_port_info {
    pub name: *const c_char,
    pub description: *const c_char,
    pub priority: c_uint,
    pub available: c_int,
    pub direction: c_int,
    pub n_profiles: c_uint,
    pub profiles: *mut *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub latency_offset: i64,
    pub profiles2: *mut *mut pa_card_profile_info2,
}

impl ::std::default::Default for pa_card_port_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_card_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub owner_module: c_uint,
    pub driver: *const c_char,
    pub n_profiles: c_uint,
    pub profiles: *mut pa_card_profile_info,
    pub active_profile: *mut pa_card_profile_info,
    pub proplist: *mut pa_proplist,
    pub n_ports: c_uint,
    pub ports: *mut *mut pa_card_port_info,
    pub profiles2: *mut *mut pa_card_profile_info2,
    pub active_profile2: *mut pa_card_profile_info2,
}

impl ::std::default::Default for pa_card_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_card_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_card_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_sink_input_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub owner_module: c_uint,
    pub client: c_uint,
    pub sink: c_uint,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub volume: pa_cvolume,
    pub buffer_usec: pa_usec_t,
    pub sink_usec: pa_usec_t,
    pub resample_method: *const c_char,
    pub driver: *const c_char,
    pub mute: c_int,
    pub proplist: *mut pa_proplist,
    pub corked: c_int,
    pub has_volume: c_int,
    pub volume_writable: c_int,
    pub format: *mut pa_format_info,
}

impl ::std::default::Default for pa_sink_input_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_sink_input_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_sink_input_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_source_output_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub owner_module: c_uint,
    pub client: c_uint,
    pub source: c_uint,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub buffer_usec: pa_usec_t,
    pub source_usec: pa_usec_t,
    pub resample_method: *const c_char,
    pub driver: *const c_char,
    pub proplist: *mut pa_proplist,
    pub corked: c_int,
    pub volume: pa_cvolume,
    pub mute: c_int,
    pub has_volume: c_int,
    pub volume_writable: c_int,
    pub format: *mut pa_format_info,
}

impl ::std::default::Default for pa_source_output_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_source_output_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_source_output_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_stat_info {
    pub memblock_total: c_uint,
    pub memblock_total_size: c_uint,
    pub memblock_allocated: c_uint,
    pub memblock_allocated_size: c_uint,
    pub scache_size: c_uint,
}

impl ::std::default::Default for pa_stat_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_stat_info_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, i: *const pa_stat_info, userdata: *mut c_void),
>;

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_sample_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub volume: pa_cvolume,
    pub sample_spec: pa_sample_spec,
    pub channel_map: pa_channel_map,
    pub duration: pa_usec_t,
    pub bytes: c_uint,
    pub lazy: c_int,
    pub filename: *const c_char,
    pub proplist: *mut pa_proplist,
}

impl ::std::default::Default for pa_sample_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_sample_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_sample_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;

pulse_enum! {
    pub enum pa_autoload_type_t {
        PA_AUTOLOAD_SINK,
        PA_AUTOLOAD_SOURCE,
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct pa_autoload_info {
    pub index: c_uint,
    pub name: *const c_char,
    pub kind: pa_autoload_type_t,
    pub module: *const c_char,
    pub argument: *const c_char,
}

impl ::std::default::Default for pa_autoload_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

pub type pa_autoload_info_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        i: *const pa_autoload_info,
        eol: c_int,
        userdata: *mut c_void,
    ),
>;
pub type pa_context_subscribe_cb_t = Option<
    unsafe extern "C" fn(
        c: *mut pa_context,
        t: pa_subscription_event_type_t,
        idx: c_uint,
        userdata: *mut c_void,
    ),
>;
pub type pa_context_play_sample_cb_t = Option<
    unsafe extern "C" fn(c: *mut pa_context, idx: c_uint, userdata: *mut c_void),
>;

pub enum pa_threaded_mainloop {}
pub enum pollfd {}
pub enum pa_mainloop {}

pub type pa_poll_func = Option<
    unsafe extern "C" fn(ufds: *mut pollfd, nfds: c_ulong, timeout: c_int, userdata: *mut c_void)
        -> c_int,
>;
pub enum pa_signal_event {}

pub type pa_signal_cb_t = Option<
    unsafe extern "C" fn(
        api: *mut pa_mainloop_api,
        e: *mut pa_signal_event,
        sig: c_int,
        userdata: *mut c_void,
    ),
>;
pub type pa_signal_destroy_cb_t = Option<
    unsafe extern "C" fn(api: *mut pa_mainloop_api, e: *mut pa_signal_event, userdata: *mut c_void),
>;
